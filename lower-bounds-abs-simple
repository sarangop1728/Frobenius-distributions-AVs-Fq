#quickly calculate a lower bound on the angle rank
#using the techniques of Cor 3.7 from DKZB paper,
#generalized to arbitrary primes, and any set of Newton slopes
import numpy as np



#function to create matrix with 0's and 1's in the right place.
def create_array(g, r, q):
    j=0;
    C=Combinations(range(1,g+1), r)
    mat=np.ones([g,C.cardinality()]);
    for subset in C.list():
        for i in subset:
            mat[i-1][j]=0
        j=j+1;
    mat_q = matrix(GF(q),mat)
    return mat_q;

def return_num_zeros(slope_list,q, full=True):
    r=0 #zero counter
    for slope in slope_list:
        a=slope.numerator()
        b=slope.denominator()
        if (2*a)%q == b%q:
            r=r+1;
    if full==True and r%2 !=0:
        print('Something is wrong with your list of slopes.')
        print('If you entered only half the slopes, set full=False')
        #remove this once you optimize the input to be only half the slopes
    return r/2;
            
def rank_lower_bound(slope_list, g, q):
    r = return_num_zeros(slope_list, q)
    M=create_array(g,r,q)
    return M.rank()

#examples

#test data
#p=5 #characteristic
#q=2 #prime to calculate rank with
slopes=[0,0, 1/4, 1/4, 1/4, 1/4, 1/3, 1/3, 1/3, 2/3,2/3, 2/3, 3/4, 3/4, 3/4, 3/4, 1, 1]
rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 15)]
print(rank_bounds)

##Output: [9, 1, 1, 1, 1, 1]



#######################################
#OUTPUT
#######################################

# slopes=[1/5]*5+[1/4]*4 + [3/4]*4 + [4/5]*5
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 15)]
# sage: print(rank_bounds)
# [9, 9, 1, 1, 1, 1]

# sage: slopes=[1/7]*7 + [1/5]*5 + [1/3]*3 + [2/3]*3+ [4/5]*5 + [6/7]*7
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 15)]
# sage: print(rank_bounds)
# [1, 15, 15, 1, 1, 1]

# slopes=[1/16]*16 + [15/16]*16
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 15)]
# sage: print(rank_bounds)
# [0, 1, 1, 0, 1, 1]
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [0, 1, 1, 0, 1, 1, 1, 1, 1, 1]

# sage: slopes=[3/16]*16 + [13/16]*16
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [0, 1, 0, 1, 1, 1, 1, 1, 1, 1]

# sage: slopes=[3/8]*16 + [5/8]*16
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]

# sage: slopes=[1/17]*17 + [16/17]*17
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [1, 0, 0, 1, 1, 1, 1, 1, 1, 1]

# sage: slopes=[2/17]*17 + [15/17]*17
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [1, 1, 1, 1, 1, 0, 1, 1, 1, 1]

# slopes=[1/25]*25 + [24/25]*25
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [1, 1, 1, 1, 1, 1, 1, 1, 0, 1]

# slopes=[3/16]*16 + [13/16]*16 +[0]*2 + [1]*2
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [17, 1, 18, 1, 1, 1, 1, 1, 1, 1]

###########################################################
###take some of these and add in some 0's and 1's: estimates become much higher: is this a math consequence or a computational consequence?
###i.e. is the angle rank in the former case low or is this a bad way to estimate it?
# slopes=[3/16]*16 + [13/16]*16 +[0]*2 + [1]*2
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [17, 1, 18, 1, 1, 1, 1, 1, 1, 1]

# sage: slopes=[2/17]*17 + [15/17]*17+[0]+[1]
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [1, 1, 1, 1, 1, 18, 1, 1, 1, 1]

# slopes=[1/17]*17 + [16/17]*17+[0]+[1]
# sage: rank_bounds=[rank_lower_bound(slopes, len(slopes)/2, q) for q in prime_range(2, 30)]
# sage: print(rank_bounds)
# [1, 18, 18, 1, 1, 1, 1, 1, 1, 1]

##########
#NT or lin_alg question: If there are a non-zero number of 0 slopes, is there a prime for which we get a good lower bound using this technique?
#Harder question: Is there an absolutely simple abelian variety with these Newton polygons?